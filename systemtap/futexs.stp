# https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/systemtap_beginners_guide/futexcontentionsect
# with adaptions for more recent kernel (cf. FUTEX_CMD_MASK)

# This script tries to identify contended user-space locks by hooking
# into the futex system call.

global thread_thislock # short
global thread_blocktime # 
global FUTEX_WAIT = 0 /*, FUTEX_WAKE = 1 */

global lock_waits # long-lived stats on (tid,lock) blockage elapsed time
global process_names # long-lived pid-to-execname mapping

probe syscall.futex {  
  if(pid()!=target()) next
  if (op&0x7f != FUTEX_WAIT) next # don't care about WAKE event originator
  t = tid ()
  process_names[pid()] = execname()
  thread_thislock[t] = futex_uaddr
  thread_blocktime[t] = gettimeofday_us()
}

probe syscall.futex.return {  
  if(pid()!=target()) next
  t = tid()
  ts = thread_blocktime[t]
  if (ts) {
    elapsed = gettimeofday_us() - ts
    lock_waits[t, thread_thislock[t]] <<< elapsed
    delete thread_blocktime[t]
    delete thread_thislock[t]
  }
}

probe begin {
    printf("Start with target=%d...\n", target())
}
probe end {
  foreach ([tid+, lock] in lock_waits) 
    printf ("[%d] lock %p contended %d times, %d avg us\n",
            tid, lock, @count(lock_waits[tid,lock]),
            @avg(lock_waits[tid,lock]))
}
