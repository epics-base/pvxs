/**
* Copyright - See the COPYRIGHT that is included with this distribution.
 * pvxs is distributed subject to a Software License Agreement found
 * in file LICENSE that is included with this distribution.
 */

#ifndef CERT_CONTEXT_H
#define CERT_CONTEXT_H

#include <vector>

#include <epicsUnitTest.h>

#include <pvxs/client.h>
#include <pvxs/source.h>
#include <pvxs/unittest.h>

#include "certstatusfactory.h"
#include "certstatusmanager.h"
#include "ownedptr.h"

#define STATUS_VALID_FOR_MINS 30
#define STATUS_VALID_FOR_SECS (STATUS_VALID_FOR_MINS * 60)
#define STATUS_VALID_FOR_SHORT_SECS 100
#define REVOKED_SINCE_MINS (60 * 12)
#define REVOKED_SINCE_SECS (REVOKED_SINCE_MINS * 60)

/**
 * @brief The test keychain file names generated by gen_test_certs
 * Use `superserver1` as the Mock PCACMS certificate as it is generated without the certificate status custom extension
 */
#define CERT_AUTH_KEYCHAIN_FILE "cert_auth.p12"
#define CERT_AUTH_KEYCHAIN_FILE_PWD ""
#define CERT_AUTH_CERT_FILE "cert_authcert.p12"
#define CERT_AUTH_CERT_FILE_PWD ""
#define SUPER_SERVER_KEYCHAIN_FILE "superserver1.p12"
#define SUPER_SERVER_KEYCHAIN_FILE_PWD ""
#define SUPER_SERVER2_KEYCHAIN_FILE "superserver2.p12"
#define SUPER_SERVER2_KEYCHAIN_FILE_PWD ""
#define INTERMEDIATE_SERVER_KEYCHAIN_FILE "intermediateCA.p12"
#define INTERMEDIATE_SERVER_KEYCHAIN_FILE_PWD ""
#define SERVER1_KEYCHAIN_FILE "server1.p12"
#define SERVER1_KEYCHAIN_FILE_PWD ""
#define SERVER2_KEYCHAIN_FILE "server2.p12"
#define SERVER2_KEYCHAIN_FILE_PWD ""
#define IOC1_KEYCHAIN_FILE "ioc1.p12"
#define IOC1_KEYCHAIN_FILE_PWD ""
#define CLIENT1_KEYCHAIN_FILE "client1.p12"
#define CLIENT1_KEYCHAIN_FILE_PWD ""
#define CLIENT2_KEYCHAIN_FILE "client2.p12"
#define CLIENT2_KEYCHAIN_FILE_PWD "oraclesucks"
#define CLIENT3_KEYCHAIN_FILE "client3.p12"
#define CLIENT3_KEYCHAIN_FILE_PWD ""

#define WHO_AM_I_PV "whoami"
#define TLS_METHOD_STRING "x509"
#define TCP_METHOD_STRING "ca"
#define ANON_METHOD_STRING "anonymous"

#define CERT_CN_SERVER1 "server1"
#define CERT_CN_SERVER2 "server2"
#define CERT_CN_IOC1 "ioc1"
#define CERT_CN_CLIENT1 "client1"
#define CERT_CN_CLIENT2 "client2"
#define CERT_CN_SUPERSERVER1 "superserver1"

#define TEST_PV "TESTPV"
#define TEST_PV1 "TESTPV1"
#define TEST_PV2 "TESTPV2"
#define TEST_PV_FIELD "value"

namespace pvxs {
/**
 * @brief tags for gen_test_certs generated certs
 */
namespace tag {
struct cert_auth          {};   struct super_server      {};
struct intermediate_server{};   struct server1           {};
struct server2            {};   struct ioc               {};
struct client1            {};   struct client2           {};
} // namespace tag

namespace certs {


/**
 * @brief define the traits to be used in the template class CertCtx below that will describe the individual certs
 * @tparam Tag the individual cert discriminator that will come from the CertCtx template
 */
struct TestCert;
template<typename Tag> struct CertTraits;
template<typename Tag> TestCert getTestCert();

#define TRAITS(TAG, FILE, PWD, SERIAL)            \
template<> struct CertTraits<tag::TAG> {          \
static constexpr const char *name  = #TAG;        \
static constexpr const char *file  = FILE;        \
static constexpr const char *pwd   = PWD;         \
static constexpr std::uint64_t   serial = SERIAL; \
}

constexpr std::uint64_t FIRST_SERIAL = 9876543210ULL;
TRAITS(cert_auth,          CERT_AUTH_KEYCHAIN_FILE,           CERT_AUTH_KEYCHAIN_FILE_PWD,              FIRST_SERIAL+0);
TRAITS(super_server,       SUPER_SERVER_KEYCHAIN_FILE,        SUPER_SERVER_KEYCHAIN_FILE_PWD,           FIRST_SERIAL+1);
TRAITS(intermediate_server,INTERMEDIATE_SERVER_KEYCHAIN_FILE, INTERMEDIATE_SERVER_KEYCHAIN_FILE_PWD,    FIRST_SERIAL+2);
TRAITS(server1,            SERVER1_KEYCHAIN_FILE,             SERVER1_KEYCHAIN_FILE_PWD,                FIRST_SERIAL+3);
TRAITS(server2,            SERVER2_KEYCHAIN_FILE,             SERVER2_KEYCHAIN_FILE_PWD,                FIRST_SERIAL+4);
TRAITS(ioc,                IOC1_KEYCHAIN_FILE,                IOC1_KEYCHAIN_FILE_PWD,                   FIRST_SERIAL+5);
TRAITS(client1,            CLIENT1_KEYCHAIN_FILE,             CLIENT1_KEYCHAIN_FILE_PWD,                FIRST_SERIAL+6);
TRAITS(client2,            CLIENT2_KEYCHAIN_FILE,             CLIENT2_KEYCHAIN_FILE_PWD,                FIRST_SERIAL+7);
#undef TRAITS


/**
 * @class TestCert
 * @brief A class designed to handle and manage operations related to test certificates.
 *
 * The TestCert class provides functionality to work with test certificate
 * data and associated operations.
 *
 * Usage of this class typically involves creating an instance and leveraging
 * member functions to perform required certificate operations.
 *
 */
struct TestCert {
    ossl_ptr<X509> cert;
    ossl_ptr<EVP_PKEY> pkey;
    ossl_shared_ptr<STACK_OF(X509)> chain;
    ossl_ptr<X509_STORE> trusted_store;

    TestCert() = default;

    TestCert(const TestCert &) = delete;

    TestCert &operator=(const TestCert &) = delete;

    TestCert(TestCert &&other) noexcept { *this = std::move(other); }

    explicit TestCert(ossl_ptr<X509> cert,
                      ossl_shared_ptr<STACK_OF(X509)> chain = nullptr,
                      ossl_ptr<EVP_PKEY> pkey = nullptr)
        : cert(std::move(cert)), pkey(std::move(pkey)), chain(std::move(chain)), trusted_store(createTrustStore()) {
    }

    TestCert &operator=(TestCert &&rhs) noexcept {
        std::swap(cert, rhs.cert);
        std::swap(pkey, rhs.pkey);
        std::swap(chain, rhs.chain);
        std::swap(trusted_store, rhs.trusted_store);
        return *this;
    }

    ossl_ptr<X509_STORE> createTrustStore() const {
        auto trusted_store = ossl_ptr<X509_STORE>(X509_STORE_new(), false);
        if (!trusted_store) throw std::runtime_error("X509_STORE_add_cert");
        if (chain && (sk_X509_num(chain.get()) > 0)) {
            const ossl_ptr<X509> &root_cert = ossl_ptr<X509>(sk_X509_value(chain.get(), sk_X509_num(chain.get())-1));
            if (!X509_STORE_add_cert(trusted_store.get(), root_cert.get())) throw std::runtime_error(
                "X509_STORE_add_cert");
        } else {
            if (!X509_STORE_add_cert(trusted_store.get(), cert.get())) throw std::runtime_error("X509_STORE_add_cert");
        }
        return trusted_store;
    }

    explicit operator bool() const { return cert && pkey; }
};

/**
 * @brief The template class to use for test certs.  It uses traits to set values
 * @tparam Tag the tag to use as the certificate discriminator to pick up the correct traits
 */
template<typename Tag>
struct CertCtx {
    using traits = CertTraits<Tag>;

    std::string name; // The name of this trait
    TestCert cert;
    Value status_val{CertStatus::getStatusPrototype()};
    std::string pv_name;
    PVACertificateStatus status{};
    std::vector<certstatus_t> pending{};

    explicit CertCtx() : name(traits::name), cert(getTestCert<Tag>()) {
        try {
            pv_name = CertStatusManager::getStatusPvFromCert(cert.cert);
        } catch (const CertStatusNoExtensionException &e) {
            testOk(name == "super_server", "Expected %s to not to have custom cert extension", traits::file);
        }
    }

    static constexpr std::uint64_t serial() { return traits::serial; }
};

/**
 * Sets the value of a specified field in a Value object.
 *
 * This function compares the current value of the field with the provided
 * source value. If they are equal, it calls the 'unmark' method on the field
 * to indicate no change is needed. If they are not equal, it updates the field
 * with the new source value.
 *
 * @tparam Type The type of the value being set.
 * @param target The Value object containing the field to be updated.
 * @param field The name of the field within the target object to be updated.
 * @param new_value The new value to be set in the specified field.
 */
template <typename Type>
void setValue(Value &target, const std::string &field, const Type &new_value) {
    target[field] = new_value;
}
/**
 * Retrieves a test certificate from a given file and password.
 *
 * This function opens and reads a keychain file in PKCS#12 format, parses it,
 * and returns a TestCert object containing the certificate, private key, and
 * certificate chain.
 *
 * @template Tag The name of the template trait to use.
 * @return A TestCert object that holds the parsed certificate, private key, and certificate chain.
 *
 * @error If there is any error opening the file, reading the file, or parsing the PKCS#12 object,
 *        a TestCert object with nullptr values is returned and diagnostic messages are logged.
 */
template<typename Tag>
TestCert getTestCert() {
    using traits = CertTraits<Tag>;

    char buffer[PATH_MAX];
    getcwd(buffer, sizeof(buffer));

    const auto filename = std::string(traits::file);
    const auto pwd = std::string(traits::pwd);
    testDiag("Opening %s certs file", filename.c_str());
    const file_ptr fp(fopen(filename.c_str(), "rb"), false);
    if (!fp) {
        testFail("Error opening certs file for reading binary contents: %s", filename.c_str());
        throw std::runtime_error(SB() << "Error opening certs file for reading: " << filename.c_str());
    }

    testDiag("Opening %s certs file as a PKCS#12 object", filename.c_str());
    ossl_ptr<PKCS12> p12(d2i_PKCS12_fp(fp.get(), nullptr));
    if (!p12) {
        testFail("Error opening certs file as a PKCS#12 object: %s", filename.c_str());
        throw std::runtime_error(SB() << "Error opening certs file as a PKCS#12 object: " << filename.c_str());
    }

    ossl_ptr<X509> cert;
    ossl_ptr<EVP_PKEY> pkey;
    ossl_shared_ptr<STACK_OF(X509)> chain;
    STACK_OF(X509) *chain_ptr = nullptr;
    testDiag("Parsing PKCS#12 object to get certificate, key and chain");
    if (!PKCS12_parse(p12.get(), pwd.c_str(), pkey.acquire(), cert.acquire(), &chain_ptr)) {
        testFail("Error Parsing PKCS#12 object: %s", filename.c_str());
        throw std::runtime_error(SB() << "Error Parsing PKCS#12 object: " << filename.c_str());
    }

    testOk(!!cert.get(), "Certificate Acquired from %s", filename.c_str());
    testOk(!!pkey.get(), "Private Key Acquired from %s", filename.c_str());

    if (!cert || !pkey) {
        testFail("Error loading certificate: %s", filename.c_str());
        throw std::runtime_error(SB() << "Error loading certificate: " << filename.c_str());
    }

    chain = chain_ptr
                ? ossl_shared_ptr<STACK_OF(X509)>(chain_ptr)
                : ossl_shared_ptr<STACK_OF(X509)>(sk_X509_new_null());

    const auto chain_len = sk_X509_num(chain.get());
    if (filename == CERT_AUTH_KEYCHAIN_FILE)
        testOk(chain_len == 0, "Expected no chain for %s and got %d", filename.c_str(), chain_len);
    else if (filename == SUPER_SERVER_KEYCHAIN_FILE || filename == INTERMEDIATE_SERVER_KEYCHAIN_FILE)
        testOk( chain_len == 1, "Expected 1 certificate chain for %s and got %d", filename.c_str(), chain_len);
    else testOk(chain_len == 2, "Expected 2 certificate chain for %s and got %d", filename.c_str(), chain_len);

    // Test issuer load
    const X509_NAME *subject_name = X509_get_subject_name(cert.get());
    ossl_ptr<char> name(X509_NAME_oneline(subject_name, nullptr, 0), false);
    testOk(!!name.get(), "Subject Name Acquired from cert: %s", name.get());
    return TestCert(std::move(cert), std::move(chain), std::move(pkey));
}

/**
 * @brief The template class to make responses
 * @tparam Tag
 * @param cert_context
 * @param cert_status_factory
 * @param now
 * @param revocation_date
 */
template<typename Tag>
void makeStatusResponse(CertCtx<Tag> &cert_context,
                        const CertStatusFactory &cert_status_factory,
                        const CertDate &now,
                        const CertDate &revocation_date) {
    try {
        cert_context.status_val.unmark();

        setValue(cert_context.status_val, "serial", cert_context.serial());
        setValue(cert_context.status_val, "status.value.index", cert_context.status.status.i);
        setValue(cert_context.status_val, "status.timeStamp.secondsPastEpoch", now.t - POSIX_TIME_AT_EPICS_EPOCH);
        setValue(cert_context.status_val, "state", cert_context.status.status.s);
        setValue(cert_context.status_val, "ocsp_status.value.index", cert_context.status.ocsp_status.i);
        setValue(cert_context.status_val, "ocsp_status.timeStamp.secondsPastEpoch", now.t - POSIX_TIME_AT_EPICS_EPOCH);
        setValue(cert_context.status_val, "ocsp_state", (SB() << "**UNCERTIFIED**: " << cert_context.status.ocsp_status.s).str());

        if (!cert_context.status.ocsp_bytes.empty()) {
            setValue<uint32_t>(cert_context.status_val, "ocsp_status.value.index", cert_context.status.ocsp_status.i);
            setValue<std::string>(cert_context.status_val, "ocsp_state", cert_context.status.ocsp_status.s);
            setValue<std::string>(cert_context.status_val, "ocsp_status_date", cert_context.status.status_date.s);
            setValue<std::string>(cert_context.status_val, "ocsp_certified_until",
                                  cert_context.status.status_valid_until_date.s);
            setValue<std::string>(cert_context.status_val, "ocsp_revocation_date",
                                  cert_context.status.revocation_date.s);
            auto ocsp_bytes = shared_array<const uint8_t>(cert_context.status.ocsp_bytes.begin(),
                                                          cert_context.status.ocsp_bytes.end());
            cert_context.status_val["ocsp_response"] = ocsp_bytes.freeze();
        }

        testDiag("Set up: %s certificate status response", cert_context.name.c_str());

        auto converted_response = PVACertificateStatus(cert_context.status_val, cert_context.cert.trusted_store.get());
        testOk(converted_response == cert_context.status,
               "Converted status response matches expected status response for %s", cert_context.name.c_str());
        const auto converted_ocsp_byte_len = converted_response.ocsp_bytes.size();
        const auto expected_ocsp_byte_len = cert_context.status.ocsp_bytes.size();
        testOk(converted_ocsp_byte_len == expected_ocsp_byte_len,
               "Converted OCSP byte len (%lu) matches expected OCSP byte len (%zu)", converted_ocsp_byte_len,
               expected_ocsp_byte_len);

        if (!cert_context.pending.empty()) {
            cert_context.pending.erase(cert_context.pending.begin());
            if (cert_context.pending.empty()) {
                auto status = cert_context.pending[0];
                cert_context.status = (status == REVOKED)
                                          ? cert_status_factory.createPVACertificateStatus(
                                              cert_context.cert.cert, status, now, revocation_date.t)
                                          : cert_status_factory.createPVACertificateStatus(
                                              cert_context.cert.cert, status, now);
            }
        }
    } catch (std::exception &e) {
        testFail("Failed to setup %s status response: %s", cert_context.name.c_str(), e.what());
    }
}

template<typename Tag>
void createCertStatus(CertCtx<Tag> &cert_context,
                      std::vector<certstatus_t> desired,
                      const CertStatusFactory &cert_status_factory,
                      const CertDate &now,
                      const CertDate &revocation_date) {
    cert_context.pending = std::move(desired);
    if (cert_context.pending.empty()) throw std::logic_error("empty status list");

    const auto status = cert_context.pending.front();
    cert_context.status = (status == REVOKED)
                     ? cert_status_factory.createPVACertificateStatus(cert_context.cert.cert, status, now, revocation_date.t)
                     : cert_status_factory.createPVACertificateStatus(cert_context.cert.cert, status, now);
}

template<typename Tag, typename SPV>
bool postValueCase(std::uint64_t requested_serial, SPV &shared_pv, const std::string &name, CertCtx<Tag> &cert_context, bool first) {
    if (requested_serial != cert_context.serial()) return false;
    cert_context.status_val.mark();
    first ? shared_pv.open(name, cert_context.status_val) : shared_pv.post(name, cert_context.status_val);
    return true;
}

template<typename Tag>
void testStatusRequest(CertCtx<Tag> &cert_context, client::Context &client, X509_STORE *trust_store) {
    auto status_value = client.get(cert_context.pv_name).exec()->wait(5.0);
    auto pva_certificate_status = PVACertificateStatus(status_value, trust_store);
    testOk1(pva_certificate_status == cert_context.status);
}

typedef std::unordered_map<std::string, std::shared_ptr<std::atomic<uint32_t> > > CounterMap;

template<typename Tag>
void resetCounter(CounterMap &counters, const CertCtx<Tag> &cert_context) {
    counters[cert_context.pv_name] = std::make_shared<std::atomic<uint32_t> >(0u);
}

/**
 * Test that the counter is equal to the expected value
 *
 * @tparam Tag the tag of the certificate context to check
 * @param counters
 * @param cert_context
 * @param expected
 */
template<typename Tag>
void testCounterEq(const CounterMap &counters, const CertCtx<Tag> &cert_context, const uint32_t expected) {
    const auto it = counters.find(cert_context.pv_name);
    if (it == counters.end()) {
        testFail("No counter stored for PV \"%s\"", cert_context.pv_name.c_str());
        return;
    }
    testOk(it->second->load() == expected, "Expected counter of requests for %s's cert to be %u, got %u", cert_context.name.c_str(), expected, it->second->load());
}
} // namespace certs

namespace server {

class MockSource final : public Source {
    std::shared_ptr<Source> next_;
    std::function<void(const std::string &)> request_counter_;

    public:
        explicit MockSource(std::shared_ptr<Source> inner,
                            std::function<void(const std::string &)> request_counter = [](const std::string &) {
                            })
            : next_(std::move(inner)), request_counter_(std::move(request_counter)) {
        }

        void onSearch(Search &req) override { next_->onSearch(req); }

        List onList() override { return next_->onList(); }

        void show(std::ostream &strm) override { next_->show(strm); }

        void onCreate(std::unique_ptr<ChannelControl> &&chan) override {
            request_counter_(chan->name());
            next_->onCreate(std::move(chan));
        }
};

} // server
} // pvxs
#endif //CERT_CONTEXT_H
