// Created on 01/10/2024.
//

#ifndef PVXS_TESTCERTS_H_
#define PVXS_TESTCERTS_H_

#include <sstream>

#include <epicsUnitTest.h>
#include <testMain.h>

#include <pvxs/client.h>
#include <pvxs/log.h>
#include <pvxs/nt.h>
#include <pvxs/server.h>
#include <pvxs/sharedpv.h>
#include <pvxs/source.h>
#include <pvxs/unittest.h>

#include "certfactory.h"
#include "certstatus.h"
#include "certstatusfactory.h"
#include "certstatusmanager.h"
#include "ownedptr.h"
#include "utilpvt.h"

using namespace pvxs;
using namespace pvxs::certs;

#define STATUS_VALID_FOR_MINS 30
#define STATUS_VALID_FOR_SECS (STATUS_VALID_FOR_MINS * 60)
#define STATUS_VALID_FOR_SHORT_SECS 1
#define REVOKED_SINCE_MINS (60 * 12)
#define REVOKED_SINCE_SECS (REVOKED_SINCE_MINS * 60)

#define TEST_FIRST_SERIAL 9876543210

#define GET_MONITOR_CERT_STATUS_PV "CERT:STATUS:????????:*"

/**
 * @brief The test keychain file names generated by gen_test_certs
 * Use `superserver1` as the Mock PCACMS certificate as it is generated without the certificate status custom extension
 */
#define CERT_AUTH_KEYCHAIN_FILE "cert_auth.p12"
#define CERT_AUTH_KEYCHAIN_FILE_PWD ""
#define CERT_AUTH_CERT_FILE "cert_authcert.p12"
#define CERT_AUTH_CERT_FILE_PWD ""
#define SUPER_SERVER_KEYCHAIN_FILE "superserver1.p12"
#define SUPER_SERVER_KEYCHAIN_FILE_PWD ""
#define SUPER_SERVER2_KEYCHAIN_FILE "superserver2.p12"
#define SUPER_SERVER2_KEYCHAIN_FILE_PWD ""
#define INTERMEDIATE_SERVER_KEYCHAIN_FILE "intermediateCA.p12"
#define INTERMEDIATE_SERVER_KEYCHAIN_FILE_PWD ""
#define SERVER1_KEYCHAIN_FILE "server1.p12"
#define SERVER1_KEYCHAIN_FILE_PWD ""
#define SERVER2_KEYCHAIN_FILE "server2.p12"
#define SERVER2_KEYCHAIN_FILE_PWD ""
#define IOC1_KEYCHAIN_FILE "ioc1.p12"
#define IOC1_KEYCHAIN_FILE_PWD ""
#define CLIENT1_KEYCHAIN_FILE "client1.p12"
#define CLIENT1_KEYCHAIN_FILE_PWD ""
#define CLIENT2_KEYCHAIN_FILE "client2.p12"
#define CLIENT2_KEYCHAIN_FILE_PWD "oraclesucks"
#define CLIENT3_KEYCHAIN_FILE "client3.p12"
#define CLIENT3_KEYCHAIN_FILE_PWD ""

#define WHO_AM_I_PV "whoami"
#define TLS_METHOD_STRING "x509"
#define TCP_METHOD_STRING "ca"
#define ANON_METHOD_STRING "anonymous"

#define CERT_CN_SERVER1 "server1"
#define CERT_CN_SERVER2 "server2"
#define CERT_CN_IOC1 "ioc1"
#define CERT_CN_CLIENT1 "client1"
#define CERT_CN_CLIENT2 "client2"
#define CERT_CN_SUPERSERVER1 "superserver1"

#define TEST_PV "TESTPV"
#define TEST_PV1 "TESTPV1"
#define TEST_PV2 "TESTPV2"
#define TEST_PV_FIELD "value"

/**
 * @brief Generate the member variables required to store the named certificate
 * @code
 * DEFINE_MEMBERS(name)
 * @endcode
 * @param LNAME lowercase name of the certificate
 */
#define DEFINE_MEMBERS(LNAME)                                    \
    const TestCert LNAME##_cert;                                 \
    Value LNAME##_status_response_value{status_value_prototype}; \
    std::string LNAME##_status_pv_name;                          \
    PVACertificateStatus LNAME##_cert_status;                    \
    std::vector<certstatus_t> LNAME##_cert_statuses;             \
    int LNAME##_cert_status_response_counter{0};

/**
 * @brief set the appropriate member variable with the name of the PV to get status for a specific certificate
 * @code
 * SET_PV(name)
 * @endcode
 * @param LNAME lowercase name of the certificate
 */
#define SET_PV(LNAME) LNAME##_status_pv_name = CertStatusManager::getStatusPvFromCert(LNAME##_cert.cert);

/**
 * @brief Generates initializer code fragment for the appropriate certificate structure from the keychain file(s)
 * @code
 *     Tester()
 *     : now(time(nullptr))
 *     , status_valid_until_time(now.t + STATUS_VALID_FOR_SECS)
 *     , revocation_date(now.t - REVOKED_SINCE_SECS)
 *
 *      INIT_CERT_MEMBER_FROM_FILE(name,NAME)
 *      { ...
 * @endcode
 * @param LNAME lowercase name of the certificate
 * @param UNAME uppercase name of the certificate
 */
#define INIT_CERT_MEMBER_FROM_FILE(LNAME, UNAME) , LNAME##_cert(getTestCert(UNAME##_KEYCHAIN_FILE, UNAME##_KEYCHAIN_FILE_PWD))

/**
 * @brief Generates the appropriate code fragment that tests whether the certificate member has been successfully initialized
 * @code
 * if (CHECK_CERT_MEMBER_CONDITION(name)) { ...
 * @endcode
 * @param LNAME lowercase name of the certificate
 */
#define CHECK_CERT_MEMBER_CONDITION(LNAME) !LNAME##_cert.cert || !LNAME##_cert.pkey

/**
 * @brief Generates a switch case statement to handle posting of a response value in the mock PVACMS
 * for a request for status for the given certificate
 * @code
 *    if (status_pv.isOpen(pv_name)) {
 *     switch (serial) {
 *         POST_VALUE_CASE(name,post)
 *         POST_VALUE_CASE(super_server,post)
 *         default:
 *             testFail("Unknown PV Accessed for Status Request: %s", pv_name.c_str());
 *     }
 * } else {
 *     switch (serial) {
 *         POST_VALUE_CASE(name,open)
 *         POST_VALUE_CASE(super_server,open)
 *         default:
 *             testFail("Unknown PV Accessed for Status Request: %s", pv_name.c_str());
 *     }
 * }
 * @endcode
 * @param LNAME lowercase name of the certificate
 * @param ACTION post or open depending on whether this is the initial value or subsequent values
 */
#define POST_VALUE_CASE(LNAME, ACTION)                                                                                                               \
    case LNAME##_serial:                                                                                                                             \
        LNAME##_status_response_value.mark();                                                                                                        \
        pv.ACTION(pv_name, LNAME##_status_response_value);                                                                                           \
        LNAME##_cert_status_response_counter++;                                                                                                      \
        testOk(1, "PV: %s / RESPONSE: %d / VALUE: %s", pv_name.c_str(), LNAME##_cert_status_response_counter, LNAME##_cert_status.status.s.c_str()); \
        {                                                                                                                                            \
            auto cert_status_creator(CertStatusFactory(cert_auth_cert.cert, cert_auth_cert.pkey, cert_auth_cert.chain, 0, STATUS_VALID_FOR_SECS));                        \
            MAKE_STATUS_RESPONSE(LNAME)                                                                                                              \
        }                                                                                                                                            \
        break;

/**
 * @brief reset the counter for the given status response
 * @param LNAME the name of the counter to reset
 */
#define RESET_COUNTER(LNAME) LNAME##_cert_status_response_counter = 0;

/**
 * @brief Test that the counter value is correct
 * @param LNAME the name of the counter to test
 * @param VAL the expected value
 */
#define TEST_COUNTER_EQ(LNAME, VAL) testEq(LNAME##_cert_status_response_counter, VAL);

/**
 * @brief Generates the code fragment that will set the member variable holding the certificate status to be
 * returned for status requests for the given certificate from the Mock PVACMS server
 * @param LNAME lowercase name of the certificate
 * @param STATUSES the statuses to set the member variable to.
 *              each status is one of `UNKNOWN`, `PENDING_APPROVAL`, `PENDING`, `VALID`, `EXPIRED` or `REVOKED`
 *              and the statuses are in the order they should be returned for the certificate each time
 *              the status is requested
 */
#define CREATE_CERT_STATUS(LNAME, STATUSES)                                                                                      \
    try {                                                                                                                        \
        testDiag("Creating OCSP " #STATUSES " status from: %s", #LNAME " certificate");                                          \
        LNAME##_cert_statuses = STATUSES;                                                                                        \
        auto _s = LNAME##_cert_statuses[0];                                                                                      \
        if (_s == REVOKED)                                                                                                       \
            LNAME##_cert_status = cert_status_creator.createPVACertificateStatus(LNAME##_cert.cert, _s, now, revocation_date.t); \
        else                                                                                                                     \
            LNAME##_cert_status = cert_status_creator.createPVACertificateStatus(LNAME##_cert.cert, _s, now);                    \
        testOk(1, "Created initial OCSP %s status from: %s", ((PVACertStatus)_s).s.c_str(), #LNAME " certificate");              \
    } catch (std::exception & e) {                                                                                               \
        testFail("Failed to create " #STATUSES " status: %s\n", e.what());                                                       \
    }

/**
 * @brief Generates the code fragment that will make a status response and set the appropriate member variable
 * based on the given certificate.  It will also test that the status value that it can be converted into
 * matches the expected one
 * @param LNAME lowercase name of the certificate
 */
#define MAKE_STATUS_RESPONSE(LNAME)                                                                                                           \
    try {                                                                                                                                     \
        LNAME##_status_response_value = CertStatus::getStatusPrototype().cloneEmpty();                                                        \
        LNAME##_status_response_value.unmark();                                                                                               \
        setValue<uint64_t>(LNAME##_status_response_value, "serial", LNAME##_serial);                                                          \
        setValue<uint32_t>(LNAME##_status_response_value, "status.value.index", LNAME##_cert_status.status.i);                                \
        setValue<time_t>(LNAME##_status_response_value, "status.timeStamp.secondsPastEpoch", time(nullptr));                                  \
        setValue<std::string>(LNAME##_status_response_value, "state", LNAME##_cert_status.status.s);                                          \
        setValue<uint32_t>(LNAME##_status_response_value, "ocsp_status.value.index", LNAME##_cert_status.ocsp_status.i);                      \
        setValue<time_t>(LNAME##_status_response_value, "ocsp_status.timeStamp.secondsPastEpoch", time(nullptr));                             \
        setValue<std::string>(LNAME##_status_response_value, "ocsp_state", SB() << "**UNCERTIFIED**: " << LNAME##_cert_status.ocsp_status.s); \
                                                                                                                                              \
        if (!LNAME##_cert_status.ocsp_bytes.empty()) {                                                                                        \
            setValue<uint32_t>(LNAME##_status_response_value, "ocsp_status.value.index", LNAME##_cert_status.ocsp_status.i);                  \
            setValue<std::string>(LNAME##_status_response_value, "ocsp_state", LNAME##_cert_status.ocsp_status.s);                            \
            setValue<std::string>(LNAME##_status_response_value, "ocsp_status_date", LNAME##_cert_status.status_date.s);                      \
            setValue<std::string>(LNAME##_status_response_value, "ocsp_certified_until", LNAME##_cert_status.status_valid_until_date.s);      \
            setValue<std::string>(LNAME##_status_response_value, "ocsp_revocation_date", LNAME##_cert_status.revocation_date.s);              \
            auto ocsp_bytes = shared_array<const uint8_t>(LNAME##_cert_status.ocsp_bytes.begin(), LNAME##_cert_status.ocsp_bytes.end());      \
            LNAME##_status_response_value["ocsp_response"] = ocsp_bytes.freeze();                                                             \
        }                                                                                                                                     \
        testDiag("Set up: %s", #LNAME " certificate Status Response");                                                                        \
                                                                                                                                              \
        auto converted_response = PVACertificateStatus(LNAME##_status_response_value, trusted_store.get());                                                  \
        testOk1(converted_response == LNAME##_cert_status);                                                                                   \
        testEq(converted_response.ocsp_bytes.size(), LNAME##_cert_status.ocsp_bytes.size());                                                  \
                                                                                                                                              \
        if (!LNAME##_cert_statuses.empty()) {                                                                                                 \
            LNAME##_cert_statuses.erase(LNAME##_cert_statuses.begin());                                                                       \
            if (!LNAME##_cert_statuses.empty()) {                                                                                             \
                auto _s = LNAME##_cert_statuses[0];                                                                                           \
                if (_s == REVOKED)                                                                                                            \
                    LNAME##_cert_status = cert_status_creator.createPVACertificateStatus(LNAME##_cert.cert, _s, now, revocation_date.t);      \
                else                                                                                                                          \
                    LNAME##_cert_status = cert_status_creator.createPVACertificateStatus(LNAME##_cert.cert, _s, now);                         \
            }                                                                                                                                 \
        }                                                                                                                                     \
    } catch (std::exception & e) {                                                                                                            \
        testFail("Failed to setup " #LNAME " status response: %s", e.what());                                                                 \
    }

#define TEST_STATUS_REQUEST(LNAME)                                                                                       \
    try {                                                                                                                \
        testDiag("Sending: %s", "Server Status Request");                                                                \
        auto result = client.get(LNAME##_status_pv_name).exec()->wait(5.0);                                              \
        auto LNAME##_status_response = PVACertificateStatus(result, trusted_store.get());                                       \
        testOk1(LNAME##_status_response == LNAME##_cert_status);                                                         \
        testOk1(LNAME##_status_response == LNAME##_cert_status);                                                         \
        testOk1((CertifiedCertificateStatus)LNAME##_status_response == LNAME##_cert_status);                             \
        testOk1((CertifiedCertificateStatus)LNAME##_status_response == (CertifiedCertificateStatus)LNAME##_cert_status); \
        testOk1(LNAME##_status_response == (CertifiedCertificateStatus)LNAME##_cert_status);                             \
        if (LNAME##_cert_status.status == VALID || LNAME##_cert_status.status == REVOKED)                                \
            testOk1((OCSPStatus)LNAME##_status_response == LNAME##_cert_status);                                         \
        else                                                                                                             \
            testOk1(((OCSPStatus)LNAME##_status_response).ocsp_status == OCSP_CERTSTATUS_UNKNOWN);                       \
        testOk1((OCSPStatus)LNAME##_status_response == (OCSPStatus)LNAME##_cert_status);                                 \
        if (LNAME##_cert_status.status == VALID || LNAME##_cert_status.status == REVOKED)                                \
            testOk1(LNAME##_status_response == (OCSPStatus)LNAME##_cert_status);                                         \
        else                                                                                                             \
            testOk1(((OCSPStatus)LNAME##_cert_status).ocsp_status == OCSP_CERTSTATUS_UNKNOWN);                           \
        testDiag("Successfully Received: %s", "Server Status Response");                                                 \
    } catch (std::exception & e) {                                                                                       \
        testFail("Failed to send Server Status Request: %s", e.what());                                                  \
    }

/**
 * @brief Certificate serial numbers used by test system and generated by gen_test_certs
 */
constexpr uint64_t cert_auth_serial = TEST_FIRST_SERIAL;
constexpr uint64_t super_server_serial = cert_auth_serial + 1;
constexpr uint64_t intermediate_server_serial = cert_auth_serial + 2;
constexpr uint64_t server1_serial = cert_auth_serial + 3;
constexpr uint64_t server2_serial = cert_auth_serial + 4;
constexpr uint64_t ioc_serial = cert_auth_serial + 5;
constexpr uint64_t client1_serial = cert_auth_serial + 6;
constexpr uint64_t client2_serial = cert_auth_serial + 7;

/**
 * @class TestCert
 * @brief The TestCert class encapsulates a certificate, its chain, and a private key.
 *
 * This structure holds an X509 certificate, a chain of X509 certificates, and an EVP_PKEY
 * private key object. It utilizes our ossl shared and unique pointers for memory management.
 *
 * @var ossl_ptr<X509> TestCert::cert
 *      X509 certificate encapsulated by this TestCert.
 *
 * @var ossl_shared_ptr<STACK_OF(X509)> TestCert::chain
 *      Chain of X509 certificates associated with this TestCert.
 *
 * @var ossl_ptr<EVP_PKEY> TestCert::pkey
 *      Private key corresponding to the certificate.
 *
 * @fn TestCert::TestCert(ossl_ptr<X509> cert, ossl_shared_ptr<stack_st_X509> chain, ossl_ptr<EVP_PKEY> pkey)
 * @brief Constructs a new TestCert object.
 * @param cert X509 certificate to initialize the TestCert.
 * @param chain Chain of X509 certificates to initialize the TestCert.
 * @param pkey Private key to initialize the TestCert.
 */
struct TestCert {
    ossl_ptr<X509> cert;
    ossl_shared_ptr<STACK_OF(X509)> chain;
    ossl_ptr<EVP_PKEY> pkey;

    TestCert(ossl_ptr<X509> cert=nullptr, ossl_shared_ptr<stack_st_X509> chain=nullptr, ossl_ptr<EVP_PKEY> pkey=nullptr)
        : cert(std::move(cert)), chain(std::move(chain)), pkey(std::move(pkey)) {}

    inline ossl_ptr<X509_STORE>createTrustStore() const {
        auto trusted_store = ossl_ptr<X509_STORE>(X509_STORE_new(), false);
        if (!trusted_store) throw std::runtime_error("X509_STORE_add_cert");
        if (!X509_STORE_add_cert(trusted_store.get(), cert.get())) throw std::runtime_error("X509_STORE_add_cert");
        return trusted_store;
    }
};

/**
 * Sets the value of a specified field in a Value object.
 *
 * This function compares the current value of the field with the provided
 * source value. If they are equal, it calls the 'unmark' method on the field
 * to indicate no change is needed. If they are not equal, it updates the field
 * with the new source value.
 *
 * @tparam T The type of the value being set.
 * @param target The Value object containing the field to be updated.
 * @param field The name of the field within the target object to be updated.
 * @param source The new value to be set in the specified field.
 */
template <typename T>
void setValue(Value &target, const std::string &field, const T &source) {
    auto current = target[field];
    if (current.as<T>() == source) {
        target[field].unmark();  // Assuming unmark is a valid method for indicating no change needed
    } else {
        target[field] = source;
    }
}

/**
 * Retrieves a test certificate from a given file and password.
 *
 * This function opens and reads a keychain file in PKCS#12 format, parses it,
 * and returns a TestCert object containing the certificate, private key, and
 * certificate chain.
 *
 * @param filename The path to the PKCS#12 keychain file.
 * @param password The password to decrypt the PKCS#12 keychain file.
 * @return A TestCert object that holds the parsed certificate, private key, and certificate chain.
 *
 * @error If there is any error opening the file, reading the file, or parsing the PKCS#12 object,
 *        a TestCert object with nullptr values is returned and diagnostic messages are logged.
 */
inline TestCert getTestCert(const std::string &filename, const std::string &password) {
    char buffer[PATH_MAX];
    getcwd(buffer, sizeof(buffer));

    testDiag("Opening %s certs file", filename.c_str());
    file_ptr fp(fopen(filename.c_str(), "rb"), false);
    if (!fp) {
        testFail("Error opening certs file for reading binary contents: %s", filename.c_str());
        return {};
    }

    testDiag("Opening %s certs file as a PKCS#12 object", filename.c_str());
    ossl_ptr<PKCS12> p12(d2i_PKCS12_fp(fp.get(), nullptr));
    if (!p12) {
        testFail("Error opening certs file as a PKCS#12 object: %s", filename.c_str());
        return {};
    }

    ossl_ptr<X509> cert;
    ossl_ptr<EVP_PKEY> pkey;
    ossl_shared_ptr<STACK_OF(X509)> chain;
    STACK_OF(X509) *chain_ptr = nullptr;
    testDiag("Parsing PKCS#12 object to get certificate, key and chain");
    if (!PKCS12_parse(p12.get(), password.c_str(), pkey.acquire(), cert.acquire(), &chain_ptr)) {
        testFail("Error Parsing PKCS#12 object: %s", filename.c_str());
        return {};
    }

    testTrue(cert.get());
    testTrue(pkey.get());

    if (!cert || !pkey) {
        testFail("Error loading certificate: %s", filename.c_str());
        return {};
    }

    if (chain_ptr) {
        chain = ossl_shared_ptr<STACK_OF(X509)>(chain_ptr);
        testDiag("Acquired %d element Certificate Chain from: %s", sk_X509_num(chain.get()), filename.c_str());
    } else {
        chain = ossl_shared_ptr<STACK_OF(X509)>(sk_X509_new_null());
    }

    if (filename == CERT_AUTH_KEYCHAIN_FILE)
        testEq(sk_X509_num(chain.get()), 0);
    else if (filename == SUPER_SERVER_KEYCHAIN_FILE || filename == INTERMEDIATE_SERVER_KEYCHAIN_FILE)
        testEq(sk_X509_num(chain.get()), 1);
    else
        testEq(sk_X509_num(chain.get()), 2);

    // Test issuer load
    X509_NAME *subject_name = X509_get_subject_name(cert.get());
    ossl_ptr<char> name(X509_NAME_oneline(subject_name, nullptr, 0), false);
    testTrue(name.get());
    testDiag("Subject of %s: %s", filename.c_str(), name.get());

    testOk(1, "Loaded certificate from: %s", filename.c_str());
    return TestCert(std::move(cert), std::move(chain), std::move(pkey));
}

#endif  // PVXS_TESTCERTS_H_
